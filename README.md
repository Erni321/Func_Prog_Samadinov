# Функциональное программирование
1 Лабораторная работа

1)Climbing stairs:  
  Дан алгоритм для подсчета количества уникальных способов подняться по лестнице из n ступенек, где за один шаг можно подняться на 1 или 2 ступеньки.   
  Задача сводится к последовательности Фибоначчи:  
  F(1) = 1 (только: 1)  
  F(2) = 2 (1+1, 2)  
  F(n) = F(n-1) + F(n-2) для n > 2  
  Решение задачи на Python представлено в файле Task1.  
  Алгоритм оптимален по времени и памяти, использует только две переменные вместо массива.  
  Принцип работы:  
  Базовые случаи для n ≤ 2 возвращаем n.  
  Устанавливаем начальные значения для 1 и 2 ступенек.  
  Для каждой следующей ступеньки вычисляем сумму двух предыдущих.  
  Сдвигаем значения для следующей итерации.  

2)Jump Game II:  
  Суть задачи в нахождении минимального количества прыжков от начала массива до его конца, где каждый элемент массива показывает максимальную длину прыжка из этой позиции.  
  По сути это задача поиска кратчайшего пути в ориентированном графе.  
  Решение задачи на Python представлено в файле Task2.  
  Идея в том, чтобы на каждом шаге прыгать на максимально возможную дистанцию, но считать прыжки только когда достигаем границы предыдущего прыжка.  
  Переменные:  
  jumps — количество совершённых прыжков  
  current_end — самая дальняя позиция, которую можно достичь за текущее количество прыжков.  
  farthest — самая дальняя позиция, которую можно достичь из всех рассмотренных индексов.  
  Мы всегда знаем максимальную дистанцию, которую можем достичь за jumps прыжков.  
  Когда доходим до этой границы — делаем следующий прыжок на максимально возможную позицию из всех просмотренных.  

3)Pascal's Triangle II:  
  В задаче представлен треугольник Паскаля. Это математическая конструкция, где  
  Первая строка: [1]  
  Каждая следующая строка: начинается и заканчивается единицей.  
  Каждое внутреннее число = сумме двух чисел над ним.  
  Целью задачи является поиск одной конкретной строки треугольника Паскаля (по индексу), используя минимальную память.
  Решение задачи на Python представлено в файле Task3.
  Для вычисления строки k нам не нужны все предыдущие строки.  
  Мы используем один массив и обновляем его справа налево.  

4)Best Time to Buy and Sell Stock  
  Задача заключается в нахождении максимальной прибыли от одной сделки "купить-продать" на исторических данных цен акций.  
  Условия:  
  Можно совершить только одну транзакцию (купить один раз + продать один раз)  
  Покупать нужно до продажи  
  Нужно выбрать оптимальные дни для покупки и продажи  
  Если прибыль невозможна → вернуть 0  
  Решение задачи на Python представлено в файле Task4.  
  На каждом шаге используем локально оптимальное решение (исторический минимум)  
  Строим решение на основе предыдущих вычислений  
  Перед каждой итерацией:  
  min_price = минимальная цена до текущего индекса  
  max_profit = максимальная прибыль до текущего индекса
  Максимальная прибыль для первых k дней может быть вычислена через прибыль для первых k-1 дней  

5)Best Time to Buy and Sell Stock II  
  Задача заключается в нахождении максимальной прибыли при возможности совершать неограниченное количество сделок с акциями.  
  Условия:  
  Можно покупать и продавать многократно  
  Можно совершать сделки в один и тот же день (продать и сразу купить)  
  Одновременно можно держать только одну акцию  
  Нужно купить перед продажей (не шортовать)  
  Решение задачи на Python представлено в файле Task5.  
  Сложную задачу многократной торговли свели к простой сумме локальных прибылей  
  На каждом шаге берём локально оптимальное решение (все положительные разницы)  
  После обработки k дней: переменная profit содержит максимальную прибыль для первых k дней  
  Оптимальность доказывается тем, что любая стратегия не может получить больше, чем сумма всех возрастающих движений  
