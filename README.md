# Функциональное программирование
1 Лабораторная работа

1)Climbing stairs:  
  Дан алгоритм для подсчета количества уникальных способов подняться по лестнице из n ступенек, где за один шаг можно подняться на 1 или 2 ступеньки.   
  Задача сводится к последовательности Фибоначчи:  
  F(1) = 1 (только: 1)  
  F(2) = 2 (1+1, 2)  
  F(n) = F(n-1) + F(n-2) для n > 2  
  Решение задачи на Python представлено в файле Task1.  
  Алгоритм оптимален по времени и памяти, использует только две переменные вместо массива.  
  Принцип работы:  
  Базовые случаи для n ≤ 2 возвращаем n.  
  Устанавливаем начальные значения для 1 и 2 ступенек.  
  Для каждой следующей ступеньки вычисляем сумму двух предыдущих.  
  Сдвигаем значения для следующей итерации.  

    def climbStairs(n):
        if n <= 2:
            return n
    
        step1, step2 = 2, 1
    
        for i in range(3, n + 1):
            current = step1 + step2
            step2 = step1
            step1 = current
    
        return step1

2)Jump Game II:  
  Суть задачи в нахождении минимального количества прыжков от начала массива до его конца, где каждый элемент массива показывает максимальную длину прыжка из этой позиции.  
  По сути это задача поиска кратчайшего пути в ориентированном графе.  
  Решение задачи на Python представлено в файле Task2.  
  Идея в том, чтобы на каждом шаге прыгать на максимально возможную дистанцию, но считать прыжки только когда достигаем границы предыдущего прыжка.  
  Переменные:  
  jumps — количество совершённых прыжков  
  current_end — самая дальняя позиция, которую можно достичь за текущее количество прыжков.  
  farthest — самая дальняя позиция, которую можно достичь из всех рассмотренных индексов.  
  Мы всегда знаем максимальную дистанцию, которую можем достичь за jumps прыжков.  
  Когда доходим до этой границы — делаем следующий прыжок на максимально возможную позицию из всех просмотренных.  

    def jump(nums):
        n = len(nums)
        if n == 1:
            return 0
    
        jumps = 0
        current_end = 0
        farthest = 0
    
        for i in range(n - 1):
            farthest = max(farthest, i + nums[i])
    
            if i == current_end:
                jumps += 1
                current_end = farthest
    
                if current_end >= n - 1:
                    break
        return jumps

3)Pascal's Triangle II:  
  В задаче представлен треугольник Паскаля. Это математическая конструкция, где  
  Первая строка: [1]  
  Каждая следующая строка: начинается и заканчивается единицей.  
  Каждое внутреннее число = сумме двух чисел над ним.  
  Целью задачи является поиск одной конкретной строки треугольника Паскаля (по индексу), используя минимальную память.
  Решение задачи на Python представлено в файле Task3.
  Для вычисления строки k нам не нужны все предыдущие строки.  
  Мы используем один массив и обновляем его справа налево.  

    def getRow(rowIndex: int):
        row = [1] * (rowIndex + 1)
    
        for i in range(1, rowIndex):
            for j in range(i, 0, -1):
                row[j] = row[j] + row[j - 1]
    
        return row

4)Best Time to Buy and Sell Stock  
  Задача заключается в нахождении максимальной прибыли от одной сделки "купить-продать" на исторических данных цен акций.  
  Условия:  
  Можно совершить только одну транзакцию (купить один раз + продать один раз)  
  Покупать нужно до продажи  
  Нужно выбрать оптимальные дни для покупки и продажи  
  Если прибыль невозможна → вернуть 0  
  Решение задачи на Python представлено в файле Task4.  
  На каждом шаге используем локально оптимальное решение (исторический минимум)  
  Строим решение на основе предыдущих вычислений  
  Перед каждой итерацией:  
  min_price = минимальная цена до текущего индекса  
  max_profit = максимальная прибыль до текущего индекса
  Максимальная прибыль для первых k дней может быть вычислена через прибыль для первых k-1 дней  

    def maxProfit(prices):
        min_price = float('inf')
        max_profit = 0
    
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
    
        return max_profit
        
5)Best Time to Buy and Sell Stock II  
  Задача заключается в нахождении максимальной прибыли при возможности совершать неограниченное количество сделок с акциями.  
  Условия:  
  Можно покупать и продавать многократно  
  Можно совершать сделки в один и тот же день (продать и сразу купить)  
  Одновременно можно держать только одну акцию  
  Нужно купить перед продажей (не шортовать)  
  Решение задачи на Python представлено в файле Task5.  
  Сложную задачу многократной торговли свели к простой сумме локальных прибылей  
  На каждом шаге берём локально оптимальное решение (все положительные разницы)  
  После обработки k дней: переменная profit содержит максимальную прибыль для первых k дней  
  Оптимальность доказывается тем, что любая стратегия не может получить больше, чем сумма всех возрастающих движений  

    def maxProfit(prices):
      max_profit = 0
  
      for i in range(1, len(prices)):
          if prices[i] > prices[i - 1]:
              max_profit += prices[i] - prices[i - 1]
  
      return max_profit
